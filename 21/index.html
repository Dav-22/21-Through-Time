<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>21 Through Time</title>
<link rel="icon" type="image/x-icon" href="images/logo.png">
<link rel="preload" href="ui-click.mp3" as="audio">
<link rel="preload" href="/bgm_main.mp3" as="audio">

<style>
  :root{
    --bg:#0a0b10; --panel:#121623; --panel2:#0e1320; --edge:#2c3550;
    --gold:#f0c36a; --gold2:#c9912e; --text:#e9ecf4; --muted:#aab3c7;
  }
  *{box-sizing:border-box}
  html,body{height:100%}
  body{
    margin:0; color:var(--text); background:var(--bg);
    font:500 16px/1.35 ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto;
    overflow:hidden;
  }

  /* Animated time tunnel background */
  .backdrop{
    position:fixed; inset:0; overflow:hidden; z-index:-2;
    background:
      radial-gradient(1200px 800px at 60% -10%, #1a1f33 0%, transparent 60%),
      radial-gradient(900px 700px at 30% 110%, #0d1730 0%, transparent 60%),
      var(--bg);
  }
  .nebula{
    position:absolute; inset:-20%;
    background:conic-gradient(from 0deg, #1e2240, #141a33, #111628, #1e2240);
    filter:blur(40px) saturate(1.2) brightness(1.05);
    animation: swirl 40s linear infinite;
    opacity:.45;
  }
  .gridlines{
    position:absolute; inset:0;
    background-image: radial-gradient(circle at 50% 50%, rgba(240,195,106,.2), transparent 20%),
                      repeating-linear-gradient(0deg, rgba(255,255,255,.06) 0 1px, transparent 1px 60px),
                      repeating-linear-gradient(90deg, rgba(255,255,255,.05) 0 1px, transparent 1px 60px);
    mask: radial-gradient(ellipse at center, rgba(0,0,0,.9), rgba(0,0,0,0) 65%);
    opacity:.35;
  }
  @keyframes swirl{ to{ transform:rotate(360deg) } }

  /* Layout */
  .wrap{
    height:100%; width:100%;
    display:grid; place-items:center; padding:24px;
  }
  .frame{
    width:min(1000px, 92vw);
    text-align:center;
  }

  /* Logo slot */
  .logo{
    display:inline-flex; align-items:center; justify-content:center;
    height:min(18vh, 120px);
    margin:0 auto 14px;
  }
  .logo img{
  height:200%; 
  width:auto;
  object-fit:contain;
  filter:drop-shadow(0 14px 28px rgba(0,0,0,.45));
  }
  .title{
  font-size:clamp(28px, 4.4vw, 56px);
  font-weight:900;
  letter-spacing:.6px;
  background:linear-gradient(180deg, #fff 0%, #ffe7b3 45%, #f0c36a 100%);
  -webkit-background-clip:text;
  background-clip:text;
  color:transparent;
  text-shadow:0 6px 40px rgba(0,0,0,.6);
  }
  .subtitle{
    margin-top:4px; color:var(--muted); font-size:clamp(14px, 1.8vw, 18px);
  }

  /* CTA buttons */
  .ctaRow{
    margin:26px auto 10px; display:flex; gap:14px; justify-content:center; flex-wrap:wrap;
  }
  .btn{
    background:linear-gradient(180deg,#2a3144,#1b2030);
    border:1px solid #3a425a; color:#e9ecf4; padding:.85rem 1.6rem;
    border-radius:14px; cursor:pointer; font-weight:900; letter-spacing:.4px;
    box-shadow:inset 0 1px 0 rgba(255,255,255,.05); transition:.15s transform, .15s box-shadow;
  }
  .btn:hover{ transform:translateY(-1px); box-shadow:0 14px 30px rgba(0,0,0,.35) }
  .btn.primary{
    background:linear-gradient(180deg,var(--gold),var(--gold2));
    border-color:#ffd387; color:#1d1308;
  }
  .tiny{
    display:block; margin-top:10px; color:var(--muted); font-size:12px;
  }

  /* Era chips strip */
  .eras{
    display:flex; gap:8px; justify-content:center; margin:18px 0 6px;
    opacity:.9; flex-wrap:wrap;
  }
  .eraChip{
    padding:.35rem .6rem; border:1px solid #343a4d; border-radius:999px;
    background:#0d111a; color:#cfd8ea; font-size:12px;
  }

  /* Panels (Options / Credits) */
  .overlay{ position:fixed; inset:0; background:rgba(0,0,0,.55); display:none; z-index:50 }
  .modal{
    position:fixed; left:50%; top:50%; transform:translate(-50%,-50%);
    width:min(700px,92vw);
    background:linear-gradient(180deg,var(--panel),var(--panel2));
    border:1px solid var(--edge); border-radius:18px; padding:16px; z-index:60;
    display:none; box-shadow:0 30px 70px rgba(0,0,0,.55);
  }
  .modal h3{ margin:4px 0 10px }
  .row{ display:grid; grid-template-columns:160px 1fr auto; gap:10px; align-items:center; margin:8px 0 }
  .row input[type=range]{ width:100% }
  .modalFooter{ display:flex; justify-content:flex-end; gap:10px; margin-top:10px }
  .muted{ color:var(--muted) }

  /* footer help */
  .help{ position:fixed; bottom:16px; left:50%; transform:translateX(-50%); color:var(--muted); font-size:13px; opacity:.85; }
</style>
</head>
<body>
  <!-- Animated BG -->
  <div class="backdrop">
    <div class="nebula"></div>
    <div class="gridlines"></div>
  </div>

  <div class="wrap">
    <main class="frame">
      <!-- LOGO SLOT: replace src with your file -->
      <div class="logo">
        <img src="images/logo.png" alt="21 Through Time Logo" />
      </div>

      <h1 class="title">21 Through Time</h1>
      <div class="subtitle">Blackjack travels across eras — master chance from stone to neon.</div>

      <!-- CTAs -->
      <div class="ctaRow">
        <button id="startBtn" class="btn primary">Start</button>
        <button id="creditsBtn" class="btn">Credits</button>
      </div>
      <span class="tiny">Press <b>Enter</b> to start</span>
    </main>
  </div>

  <!-- CREDITS -->
  <div id="crOverlay" class="overlay"></div>
  <div id="crModal" class="modal" role="dialog" aria-modal="true" aria-labelledby="crTitle">
    <h3 id="crTitle">Credits</h3>
    <p class="muted">Game Design: David Donato ✨
    <br/>Game Development: David Donato
    <br/>Art & Visuals: Steven Donato & Damien Bui
    <br/>Music & Sound: Steven Donato & Christian Ortisi
    <br/>Playtesters: David Donato, Steven Donato, Christian Ortisi & Damien Bui
    <br>Christoffer Moe Ditlevsen / Clima / courtesy of www.epidemicsound.com
    <br>Derek Fiechter & Brandon Fiechter / Cave Paintings / Prehistoric Times
    </p>
    <div class="modalFooter"><button id="crClose" class="btn">Close</button></div>
  </div>

  <div class="help">© 2025 — 21 Through Time - David D (1757104), Steven D (1756098), Damien B (1756235) & Christian O (1756850)</div>

  <audio id="uiClick" src="ui-click.mp3" preload="auto"></audio>

<script>
  // Navigation
  const startBtn = document.getElementById('startBtn');
  startBtn.addEventListener('click', ()=> window.location.href='main-menu.html');
  document.addEventListener('keydown', (e)=>{ if(e.key==='Enter') startBtn.click(); });

  // Credits modal
  const crOverlay = document.getElementById('crOverlay');
  const crModal   = document.getElementById('crModal');
  const creditsBtn= document.getElementById('creditsBtn');
  const crClose   = document.getElementById('crClose');
  function openCr(){ crOverlay.style.display='block'; crModal.style.display='block'; }
  function closeCr(){ crOverlay.style.display='none'; crModal.style.display='none'; }
  creditsBtn.addEventListener('click', openCr);
  crClose.addEventListener('click', closeCr);
  crOverlay.addEventListener('click', (e)=>{ if(e.target===crOverlay) closeCr(); });

  (() => {
  const audioEl = document.getElementById('uiClick');
  if (!audioEl) return console.warn('uiClick audio tag not found');

  // --- Config ---
  const DEFAULT_VOL = 0.35;
  const SELECTOR = `
    button,
    .btn,
    [role="button"],
    a,
    .tile,          /* your big image tiles */
    .backBtn,       /* your back-to-menu pill */
    [data-sound]    /* force sound on any element by adding this attribute */
  `;

  // Prime audio on first gesture (helps some browsers)
  window.addEventListener('pointerdown', armOnce, { once: true, passive: true });
  function armOnce() {
    try {
      audioEl.volume = DEFAULT_VOL;
      audioEl.play().then(() => { audioEl.pause(); audioEl.currentTime = 0; }).catch(()=>{});
    } catch {}
  }

  // Play helper — clone so overlapping clicks don’t cut off
  function playClick() {
    try {
      const clone = audioEl.cloneNode(true);
      clone.volume = audioEl.volume || DEFAULT_VOL;
      document.body.appendChild(clone);
      // Start on next frame to ensure DOM append is recognized (Safari quirk)
      requestAnimationFrame(() => {
        clone.play().catch(()=>{}).finally(() => setTimeout(() => clone.remove(), 1500));
      });
    } catch (e) { /* ignore */ }
  }

  // Throttle to avoid double sound (pointerdown + click)
  let lastPlayedAt = 0;
  function maybePlay() {
    const now = performance.now();
    if (now - lastPlayedAt < 120) return; // 120ms window
    lastPlayedAt = now;
    playClick();
  }

  // Find a clickable ancestor that matches our selector
  function findClickable(target) {
    return target && target.closest(SELECTOR);
  }

  // Some elements should be silent
  function isSilent(el) {
    return el && el.closest('[data-silent="true"]');
  }

  // Play on pointerdown (fires before navigation)
  document.addEventListener('pointerdown', (e) => {
    const el = findClickable(e.target);
    if (!el || isSilent(el)) return;
    maybePlay();
  }, { passive: true });

  // Keyboard activation (Enter/Space) for accessibility
  document.addEventListener('keydown', (e) => {
    if (e.repeat) return;
    if (e.key !== 'Enter' && e.key !== ' ') return;
    const el = document.activeElement;
    if (!el) return;
    if (findClickable(el) && !isSilent(el)) maybePlay();
  });

  // Optional: expose a global to tweak volume later (Options modal)
  window.UIClickSfx = {
    setVolume(v){ audioEl.volume = Math.min(Math.max(+v || 0, 0), 1); },
    getVolume(){ return audioEl.volume ?? DEFAULT_VOL; },
    test(){ playClick(); }
  };
})();

(function(){
  const SRC         = "bgm_main.mp3";        // <-- your file
  const KEY_POS     = "bgm_pos_v1";          // last playback time
  const KEY_VOL     = "bgm_vol_v1";          // saved volume (0..1)
  const KEY_ENABLED = "bgm_enabled_v1";      // future-proof toggle (not used yet)

  // Create <audio> dynamically so we don't need an element in HTML
  const bgm = new Audio(SRC);
  bgm.loop = true;
  bgm.preload = "auto";

  // Restore saved volume or default to 0.25
  let targetVol = Math.min(Math.max(parseFloat(localStorage.getItem(KEY_VOL) || "0.25"), 0), 1);
  bgm.volume = 0; // we’ll fade to targetVol after first gesture

  // Restore position (after metadata so duration is known)
  const savedPos = parseFloat(localStorage.getItem(KEY_POS) || "0");
  if (!isNaN(savedPos) && savedPos >= 0) {
    const seekWhenReady = () => {
      // small skip forward (0.2s) to avoid hearing a tiny repeat on page change
      let resumeTime = savedPos + 0.2;
      // clamp if duration is known
      if (Number.isFinite(bgm.duration) && bgm.duration > 0) {
        resumeTime = resumeTime % bgm.duration;
      }
      bgm.currentTime = resumeTime;
    };
    if (bgm.readyState >= 1) seekWhenReady();
    else bgm.addEventListener("loadedmetadata", seekWhenReady, { once:true });
  }

  // Save position periodically (+ on pagehide)
  let saveTimer = setInterval(() => {
    try { localStorage.setItem(KEY_POS, String(bgm.currentTime || 0)); } catch(e){}
  }, 1000);
  const saveNow = () => {
    try { localStorage.setItem(KEY_POS, String(bgm.currentTime || 0)); } catch(e){}
  };
  window.addEventListener("pagehide", saveNow);

  // Fade-in after first user gesture (satisfies autoplay policies)
  let started = false;
  function startBgmFadeIn(){
    if (started) return;
    started = true;
    bgm.play().then(() => {
      let v = 0;
      const step = 0.02;    // fade speed
      const tick = 120;     // ms per step
      const id = setInterval(()=>{
        v += step;
        bgm.volume = (v >= targetVol) ? (clearInterval(id), targetVol) : v;
      }, tick);
    }).catch(err => {
      // If blocked, user will need another gesture; no-op
      console.log("BGM play blocked until user interacts:", err);
      started = false;
    });
  }

  // “Gesture” listeners (any of these will start the music once)
  const armOnce = { once:true, passive:true, capture:true };
  window.addEventListener("pointerdown", startBgmFadeIn, armOnce);
  window.addEventListener("keydown",      startBgmFadeIn, armOnce);

  // Optional helpers you can use from Options UI later
  window.BGM = {
    setVolume(v){ 
      targetVol = Math.min(Math.max(+v || 0, 0), 1);
      localStorage.setItem(KEY_VOL, String(targetVol));
      // live-adjust if already playing
      if (started) bgm.volume = targetVol;
    },
    getVolume(){ return targetVol; },
    test(){ startBgmFadeIn(); } // force-start if you need to
  };

  // Clean up if needed (not strictly required)
  window.addEventListener("beforeunload", () => {
    clearInterval(saveTimer);
    saveNow();
  });
})();
</script>
</body>
</html>
